<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Framework Prostych Zak≈Çadek</title>
    <style>
        /* Prosty CSS dla stylizacji */
        body { font-family: Arial, sans-serif; }
        .tab-bar {
            display: flex;
            border-bottom: 1px solid #ccc;
            margin-bottom: 20px;
        }
        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            background-color: #f1f1f1;
            transition: background-color 0.3s;
        }
        .tab-button:hover {
            background-color: #ddd;
        }
        .tab-button.active {
            background-color: #fff;
            border-color: #ccc;
            border-bottom: 1px solid #fff; /* Opcjonalnie: 'przebija' dolnƒÖ liniƒô paska */
            font-weight: bold;
        }
        .tab-content {
            padding: 20px;
            border: 1px solid #ccc;
            display: none; /* Domy≈õlnie ukryte */
        }
        .tab-content.active {
            display: block; /* Pokazane, gdy aktywne */
        }
    </style>
</head>
<body>

    <h1>Panel anlityka danych</h1>

    <div class="tab-bar">
        <button class="tab-button active" data-tab-target="tab1">Przygotuj klucze</button>
        <button class="tab-button" data-tab-target="tab2">Przetestuj klucze</button>
        <button class="tab-button" data-tab-target="tab3">ZarzƒÖdzaj danymi</button>
    </div>

    <div class="tab-container">

        <div id="tab1" class="tab-content active">

            <h2>Tworzenie kluczy, token√≥w i schematu danych</h2>

            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                <h4>Unikalny Token (URL-safe Base64, 16 znak√≥w)</h4>
                <br>
                <input type="text" id="tokenInput" placeholder="Wprowad≈∫ token lub u≈ºyj generatora" style="width: 100%;">
                <button id="generateTokenButton" title="Generuje losowy, 16-znakowy, URL-safe Base64 token." style="white-space: nowrap;">Generuj Token</button>
            </div>

            <hr>

            <h4>Schemat Danych (JSON)</h4>
            <p>Zdefiniuj strukturƒô danych. U≈ºyj nazw p√≥l (keys) identycznych jak w bazie danych, przypisujƒÖc im typy (np. 'int', 'float', 'string', 'boolean').</p>
            <textarea id="schemaTextarea" rows="8" placeholder='{ "id": "int", "timestamp": "int", "value": "float", "description": "string" }' style="width: 100%;"></textarea>

            <hr>

            <h4>Klucz Publiczny (JWK)</h4>
            <textarea id="publicKeyTextarea" rows="6" placeholder="Tutaj pojawi siƒô wygenerowany klucz publiczny w formacie JWK" readonly style="width: 100%;"></textarea>

            <h4>Klucz Prywatny (JWK)</h4>
            <textarea id="privateKeyTextarea" rows="10" placeholder="Tutaj pojawi siƒô wygenerowany klucz prywatny w formacie JWK" readonly style="width: 100%;"></textarea>

            <button id="generateKeysButton" style="margin-top: 10px;">Generuj Klucze (JWK)</button>

            <hr>

            <button id="exportDataButton" style="background-color: #4CAF50; color: white; padding: 10px 20px; border: none; cursor: pointer;">Eksportuj Dane (JSON)</button>

            <div id="exportMessage" style="margin-top: 10px; color: green;"></div>


        </div>


        <div id="tab2" class="tab-content">



            <h2>Testowanie kluczy</h2>
                <p>Za≈Çaduj klucze i dane analityczne, wprowad≈∫ przyk≈Çadowe dane, a nastƒôpnie przetestuj proces szyfrowania/deszyfrowania oraz walidacji schematu.</p>

                <div class="file-upload-section">
                    <h4 id="pubKeyHeader">Klucz Publiczny RSA-OAEP (JWK)</h4>
                    <input type="file" id="pubKeyFile" accept="application/json" onchange="handleFileChange(this, 'publicKey');">

                    <h4 id="analyticDataHeader">Plik Danych Analitycznych (analytic.json)</h4>
                    <input type="file" id="analyticDataFile" accept="application/json" onchange="handleFileChange(this, 'analyticData');">
                </div>

                <hr>

                <div class="test-data-section">
                    <h4 id="inputDataHeader">Wprowad≈∫ Przyk≈Çadowe Dane JSON do Szyfrowania</h4>
                    <textarea id="inputDataTextarea" rows="10" cols="50" placeholder='{"id": 123, "name": "Testowy Rekord", "isActive": true}'></textarea>
                    <br>
                    <button id="testEncryptionButton" onclick="runEncryptionDecryptionTest()" disabled>
                        Testuj Szyfrowanie, Deszyfrowanie i Walidacjƒô
                    </button>

                    <h4 id="outputDataHeader">Wynik Deszyfrowania i Walidacji</h4>
                    <textarea id="outputDataTextarea" rows="10" cols="50" readonly placeholder="Odkodowana wiadomo≈õƒá pojawi siƒô tutaj po udanym te≈õcie."></textarea>
                </div>

                <h3 id="errorMessage" style="color: red; margin-top: 20px;"></h3>



        </div>



        <div id="tab3" class="tab-content">



            <h2>ZarzƒÖdzanie Danymi</h2>

                <label for="jsonFileInput">Wczytaj pliki JSON (wiele plik√≥w):</label>
                <input type="file" id="jsonFileInput" accept=".json" multiple>
                
                <h4 id="loadStatus" style="color: green; display: none;">‚úÖ Sukces: Dane JSON wczytane i po≈ÇƒÖczone!</h4>

                <hr>
                
                <label>
                    <input type="checkbox" id="useGlobalDataCheckbox" checked>
                    U≈ºyj danych ze zmiennej globalnej (zamiast serwera)
                </label>

                <hr>
                
                <div class="data-actions">
                    <button id="displayDataBtn">Wy≈õwietl Dane</button>
                    <button id="clearDataBtn">Usu≈Ñ Dane</button>
                    <button id="exportDataBtn">Eksportuj Dane</button>
                </div>

                <hr>

                <div id="dataDisplayArea" style="margin-top: 20px;"></div>



        </div>



        </div>

    <script>
        // ===============================================
        // === CZƒò≈öƒÜ G≈Å√ìWNA (Logika Prze≈ÇƒÖczania Zak≈Çadek) - logika uniwersalna dla zak≈Çadek
        // ===============================================

        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // Funkcja do prze≈ÇƒÖczania aktywnej zak≈Çadki
        function switchTab(targetId) {
            // 1. UKRYJ WSZYSTKIE TRE≈öCI ZAK≈ÅADEK i usu≈Ñ klasƒô 'active'
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            // 2. DEAKTYWUJ WSZYSTKIE PRZYCISKI
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // 3. POKA≈ª WYBRANƒÑ TRE≈öƒÜ
            const targetContent = document.getElementById(targetId);
            if (targetContent) {
                targetContent.classList.add('active');
            }

            // 4. AKTYWUJ PRZYCISK
            const targetButton = document.querySelector(`.tab-button[data-tab-target="${targetId}"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }
        }

        // Dodanie listener√≥w do wszystkich przycisk√≥w zak≈Çadek
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetId = button.getAttribute('data-tab-target');
                switchTab(targetId);
            });
        });

        /**
         * Generuje plik JSON i uruchamia jego pobieranie.
         * @param {Array<Object>} data - Dane do eksportu.
         * @param {string} fileNamePrefix - Prefiks nazwy pliku.
         */
        function downloadJSON_dated(data, fileNamePrefix) {
            const jsonString = JSON.stringify(data, null, 2); // Wciƒôcia dla czytelno≈õci
            const dateStr = new Date().toISOString(); // Format YYYY-MM-DD
            const fileName = `${fileNamePrefix}_${dateStr}.json`;
            
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Pomy≈õlnie wyeksportowano dane do pliku: ${fileName}`);
        }



        // ===============================================
        // === CZƒò≈öCI TYLKO DLA 1 ZAK≈ÅADKI
        // ===============================================


        // --- Funkcja Pomocnicza do Generowania Tokenu URL-safe Base64 ---
        /**
         * Generuje losowy ciƒÖg znak√≥w o okre≈õlonej d≈Çugo≈õci, bezpieczny dla URL (URL-safe Base64).
         * @param {number} length D≈Çugo≈õƒá tokenu.
         * @returns {string} Losowy token.
         */
        function generateUrlSafeBase64Token(length) {
            // Generuje losowe bajty
            const randomBytes = new Uint8Array(Math.ceil(length * 3 / 4));
            window.crypto.getRandomValues(randomBytes);
            
            // Konwertuje bajty na Base64 i robi URL-safe
            let base64 = btoa(String.fromCharCode(...randomBytes))
                .replace(/\+/g, '-') // '+' na '-'
                .replace(/\//g, '_'); // '/' na '_'
            
            // Usuwa znaki paddingu '='
            base64 = base64.replace(/=+$/, '');
            
            // Przytnij do ≈ºƒÖdanej d≈Çugo≈õci
            return base64.substring(0, length);
        }

        // --- Logika dla Generowania Tokenu ---
        document.getElementById('generateTokenButton').addEventListener('click', () => {
            const token = generateUrlSafeBase64Token(16);
            document.getElementById('tokenInput').value = token;
        });

        // UWAGA: Funkcje generateUrlSafeBase64Token, downloadJsonFile oraz logika 
        // obs≈Çugi przycisk√≥w 'generateTokenButton' i 'exportDataButton' 
        // sƒÖ takie same jak w poprzedniej odpowiedzi. 

        // --- Logika dla Generowania Kluczy JWK (RSA-OAEP) ---
        document.getElementById('generateKeysButton').addEventListener('click', async () => {
            const publicKeyTextarea = document.getElementById('publicKeyTextarea');
            const privateKeyTextarea = document.getElementById('privateKeyTextarea');

            try {
                // Generowanie pary kluczy RSA-OAEP
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "RSA-OAEP",
                        modulusLength: 2048, // Typowa d≈Çugo≈õƒá klucza
                        publicExponent: new Uint8Array([0x01, 0x00, 0x01]), // 65537
                        hash: "SHA-256",
                    },
                    true, // Klucze sƒÖ extractable (mo≈ºna je eksportowaƒá)
                    ["encrypt", "decrypt", "wrapKey", "unwrapKey"] // Zastosowanie kluczy (szyfrowanie)
                );

                // Eksport klucza publicznego do formatu JWK
                const publicKeyJwk = await window.crypto.subtle.exportKey(
                    "jwk",
                    keyPair.publicKey
                );
                publicKeyTextarea.value = JSON.stringify(publicKeyJwk, null, 2);

                // Eksport klucza prywatnego do formatu JWK
                const privateKeyJwk = await window.crypto.subtle.exportKey(
                    "jwk",
                    keyPair.privateKey
                );
                privateKeyTextarea.value = JSON.stringify(privateKeyJwk, null, 2);
                
                document.getElementById('exportMessage').textContent = "Klucze RSA-OAEP (2048 bit) wygenerowane pomy≈õlnie! üîí";

            } catch (e) {
                console.error("B≈ÇƒÖd podczas generowania kluczy RSA-OAEP:", e);
                publicKeyTextarea.value = "B≈ÇƒÖd generowania klucza publicznego.";
                privateKeyTextarea.value = "B≈ÇƒÖd generowania klucza prywatnego.";
                document.getElementById('exportMessage').textContent = "B≈ÇƒÖd podczas generowania kluczy. Sprawd≈∫ konsolƒô.";
            }
        });


        // --- Logika dla Eksportu Danych ---
        document.getElementById('exportDataButton').addEventListener('click', () => {
            const token = document.getElementById('tokenInput').value;
            const schema = document.getElementById('schemaTextarea').value;
            const privKey = document.getElementById('privateKeyTextarea').value;
            const pubKey = document.getElementById('publicKeyTextarea').value;
            const messageElement = document.getElementById('exportMessage');

            // Walidacja podstawowa
            if (!token || !schema || !privKey || !pubKey) {
                messageElement.textContent = "Proszƒô uzupe≈Çniƒá wszystkie pola (Token, Schemat, Klucze)!";
                messageElement.style.color = "red";
                return;
            }

            try {
                // Sprawdzenie poprawno≈õci JSONa schematu i kluczy
                const schemaObj = JSON.parse(schema);
                const privKeyObj = JSON.parse(privKey);
                const pubKeyObj = JSON.parse(pubKey);

                // 1. analytic.json
                const analyticData = {
                    token: token,
                    schema: schemaObj,
                    privKey: privKeyObj 
                };
                downloadJSON_dated(analyticData, 'analytic');

                // 2. public.json
                // Plik public.json zawiera tylko klucz publiczny
                downloadJSON_dated(pubKeyObj, 'public');
                
                messageElement.textContent = "Dane wyeksportowane pomy≈õlnie jako analytic.json i public.json! üéâ";
                messageElement.style.color = "green";

            } catch (e) {
                console.error("B≈ÇƒÖd parsowania JSON lub eksportu:", e);
                messageElement.textContent = "B≈ÇƒÖd: Upewnij siƒô, ≈ºe Schemat i Klucze sƒÖ poprawnym formatem JSON.";
                messageElement.style.color = "red";
            }
        });

        // Ustawienie warto≈õci domy≈õlnych dla schematu
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('schemaTextarea').value = 
        `{
        "record_id": "number",
        "device_name": "string",
        "is_active": "boolean"
        }`;
        });


        // ===============================================
        // === CZƒò≈öCI TYLKO DLA 2 ZAK≈ÅADKI
        // ===============================================

        // Zmienne globalne do przechowywania zaimportowanych danych
        let GLOBAL_PUB_KEY = null;
        let GLOBAL_PRIV_KEY = null;
        let GLOBAL_SCHEMA = null;
        let GLOBAL_TOKEN = null;

        const ERROR_DISPLAY = document.getElementById('errorMessage');
        const TEST_BUTTON = document.getElementById('testEncryptionButton');

        /**
         * Funkcja obs≈ÇugujƒÖca ≈Çadowanie plik√≥w i parsowanie JSON.
         * Ustawia globalne zmienne.
         * @param {HTMLInputElement} input - Element input[type="file"].
         * @param {string} type - Typ pliku ('publicKey' lub 'analyticData').
         */
        async function handleFileChange(input, type) {
            ERROR_DISPLAY.textContent = ''; // Czy≈õƒá poprzedni b≈ÇƒÖd
            if (input.files.length === 0) return;

            const file = input.files[0];
            const reader = new FileReader();

            reader.onload = async (event) => {
                try {
                    const content = event.target.result;
                    const data = JSON.parse(content);

                    if (type === 'publicKey') {
                        // Publiczny klucz RSA-OAEP w formacie JWK
                        await importPublicKey(data);
                        document.getElementById('pubKeyHeader').style.color = 'green';
                    } else if (type === 'analyticData') {
                        // Plik analytic.json zawierajƒÖcy token, schema i privKey
                        if (!data.token || !data.schema || !data.privKey) {
                            throw new Error("Plik analytic.json musi zawieraƒá 'token', 'schema' i 'privKey'.");
                        }
                        GLOBAL_TOKEN = data.token;
                        GLOBAL_SCHEMA = data.schema;
                        await importPrivateKey(data.privKey);
                        document.getElementById('analyticDataHeader').style.color = 'green';
                    }

                    checkDependencies();
                } catch (error) {
                    ERROR_DISPLAY.textContent = `B≈ÇƒÖd parsowania lub importu ${type}: ${error.message}`;
                    // W przypadku b≈Çƒôdu resetujemy zmienne i stan
                    if (type === 'publicKey') {
                        GLOBAL_PUB_KEY = null;
                        document.getElementById('pubKeyHeader').style.color = 'black';
                    } else if (type === 'analyticData') {
                        GLOBAL_PRIV_KEY = null;
                        GLOBAL_SCHEMA = null;
                        GLOBAL_TOKEN = null;
                        document.getElementById('analyticDataHeader').style.color = 'black';
                    }
                    checkDependencies();
                }
            };

            reader.readAsText(file);
        }

        /**
         * Importuje klucz publiczny RSA-OAEP (JWK) do Web Crypto API.
         * @param {object} jwk - Obiekt klucza w formacie JWK.
         */
        async function importPublicKey(jwk) {
            GLOBAL_PUB_KEY = await crypto.subtle.importKey(
                "jwk",
                jwk,
                {
                    name: "RSA-OAEP",
                    hash: "SHA-256"
                },
                true, // extractable
                ["wrapKey", "encrypt"]
            );
        }

        /**
         * Importuje klucz prywatny RSA-OAEP (JWK) do Web Crypto API.
         * @param {object} jwk - Obiekt klucza w formacie JWK.
         */
        async function importPrivateKey(jwk) {
            GLOBAL_PRIV_KEY = await crypto.subtle.importKey(
                "jwk",
                jwk,
                {
                    name: "RSA-OAEP",
                    hash: "SHA-256"
                },
                true, // extractable
                ["unwrapKey", "decrypt"]
            );
        }

        /**
         * Sprawdza, czy wszystkie niezbƒôdne klucze i schemat zosta≈Çy za≈Çadowane.
         * Uaktywnia/dezaktywuje przycisk testowy.
         */
        function checkDependencies() {
            if (GLOBAL_PUB_KEY && GLOBAL_PRIV_KEY && GLOBAL_SCHEMA) {
                TEST_BUTTON.disabled = false;
                TEST_BUTTON.textContent = 'Testuj Szyfrowanie, Deszyfrowanie i Walidacjƒô (Gotowe)';
            } else {
                TEST_BUTTON.disabled = true;
                TEST_BUTTON.textContent = 'Testuj Szyfrowanie, Deszyfrowanie i Walidacjƒô (Oczekiwanie na klucze)';
            }
        }

        /**
         * Konwertuje ArrayBuffer na Base64 (string).
         * @param {ArrayBuffer} buffer - Bufor do konwersji.
         * @returns {string} Base64 zakodowany ciƒÖg.
         */
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        /**
         * Konwertuje Base64 (string) na ArrayBuffer.
         * @param {string} base64 - Base64 zakodowany ciƒÖg.
         * @returns {ArrayBuffer} ArrayBuffer.
         */
        function base64ToArrayBuffer(base64) {
            const binary_string = atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Waliduje typy danych w rekordzie JSON na podstawie schematu.
         * @param {object} record - Rekord danych do walidacji.
         * @param {object} schema - Schemat JSON (keys: nazwa pola, value: oczekiwany typ JS).
         * @returns {boolean} True, je≈õli walidacja pomy≈õlna.
         * @throws {Error} Je≈õli walidacja nie powiedzie siƒô.
         */
        function validateSchema(record, schema) {
            const recordKeys = Object.keys(record);
            const schemaKeys = Object.keys(schema);

            // 1. Sprawdzenie, czy rekord ma wszystkie pola ze schematu
            const missingKeys = schemaKeys.filter(key => !(key in record));
            if (missingKeys.length > 0) {
                throw new Error(`BrakujƒÖce klucze w rekordzie: ${missingKeys.join(', ')}`);
            }

            // 2. Sprawdzenie typ√≥w danych i dodatkowych kluczy
            for (const key in record) {
                if (!schema[key]) {
                    throw new Error(`Klucz '${key}' nie jest zdefiniowany w schemacie.`);
                }
                
                const expectedType = schema[key];
                const actualType = typeof record[key];

                // Sprawdzenie typu (prymitywy JS)
                if (actualType !== expectedType) {
                    throw new Error(`B≈ÇƒÖd typu dla klucza '${key}'. Oczekiwano: ${expectedType}, Otrzymano: ${actualType} (Warto≈õƒá: ${record[key]}).`);
                }
            }

            return true;
        }

        // funkcja do zakodowania wiadomo≈õci
        async function create_encrypted_message(message, GLOBAL_PUB_KEY){
            const stringifiedData = JSON.stringify(message); // 1) JSON dla wiadomo≈õci
            const dataBuffer = new TextEncoder().encode(stringifiedData); // 2) data buffer dla zakodowanych danych

            // 3) Generowanie klucza AES-GCM
            const aesKey = await crypto.subtle.generateKey(
                {
                    name: "AES-GCM",
                    length: 256,
                },
                true, // extractable
                ["encrypt", "decrypt", "wrapKey", "unwrapKey"]
            ); ¬† ¬† ¬† ¬† ¬†
            
            // 4) Generowanie IV i Wrap klucza AES-GCM (RSA-OAEP, klucz PUBLICZNY)
            const iv = crypto.getRandomValues(new Uint8Array(12)); // IV dla AES-GCM
            const wrappedKeyBuffer = await crypto.subtle.wrapKey(
                "raw",
                aesKey,
                GLOBAL_PUB_KEY,
                {
                    name: "RSA-OAEP"
                }
            ); ¬† ¬† ¬† ¬† ¬† ¬†
            
            // 5) Szyfrowanie wiadomo≈õci (AES-GCM)
            const ciphertextBuffer = await crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv: iv,
                },
                aesKey,
                dataBuffer
            ); ¬† ¬† ¬† ¬† ¬† ¬†

            // 6) konwersja zaszyfrowanych danych do base64
            const wrappedKeyBase64 = arrayBufferToBase64(wrappedKeyBuffer);
            const ivBase64 = arrayBufferToBase64(iv.buffer);
            const ciphertextBase64 = arrayBufferToBase64(ciphertextBuffer);

            // 7) zwracanie standardowego JSON dla wiadomo≈õci
            return JSON.stringify({wk: wrappedKeyBase64, iv: ivBase64, ct: ciphertextBase64});

        };


        // funkcja do odkodowania wiadomo≈õci
        async function create_decrypted_message(standard_message, GLOBAL_PRIV_KEY, GLOBAL_SCHEMA){
            try {
            // 1) parsowanie standard_message
            const sm = JSON.parse(standard_message);

            // 2) rozdzia≈Ç sm na sk≈Çadowe
            const wrappedKeyBase64 = sm.wk;
            const ivBase64 = sm.iv;
            const ciphertextBase64 = sm.ct;

            // 3) Unwrap klucza AES-GCM (RSA-OAEP, klucz PRYWATNY)
            const unwrappedKey = await crypto.subtle.unwrapKey(
                "raw",
                base64ToArrayBuffer(wrappedKeyBase64),
                GLOBAL_PRIV_KEY,
                {
                    name: "RSA-OAEP"
                },
                {
                    name: "AES-GCM"
                },
                false, // not extractable
                ["decrypt"]
            ); ¬† ¬† ¬† ¬† ¬† ¬†

            // 4) Deszyfrowanie wiadomo≈õci (AES-GCM)
            const decryptedBuffer = await crypto.subtle.decrypt(
                {
                    name: "AES-GCM",
                    iv: base64ToArrayBuffer(ivBase64),
                },
                unwrappedKey,
                base64ToArrayBuffer(ciphertextBase64)
            );

            // 5) Dekodowanie i Parsowanie wiadomo≈õci
            const decryptedString = new TextDecoder().decode(decryptedBuffer);
            const decodedData = JSON.parse(decryptedString);

            // 6. Walidacja Schematu
            validateSchema(decodedData, GLOBAL_SCHEMA);

            return decodedData;
            } catch (error) {
                // Przekazujemy b≈ÇƒÖd dalej, aby zosta≈Ç obs≈Çu≈ºony w runEncryptionDecryptionTest
                throw new Error(`B≈ÇƒÖd deszyfrowania lub walidacji: ${error.message}`);
            } ¬† ¬† ¬† ¬† ¬† ¬†
        }

        // funkcja symulujƒÖca ca≈ÇƒÖ logikƒô szyfrowania wiadomo≈õci
        async function runEncryptionDecryptionTest() {
            ERROR_DISPLAY.textContent = '';
            document.getElementById('outputDataTextarea').value = '';

            if (!GLOBAL_PUB_KEY || !GLOBAL_PRIV_KEY || !GLOBAL_SCHEMA) {
                ERROR_DISPLAY.textContent = 'Brak za≈Çadowanych kluczy lub schematu.';
                ERROR_DISPLAY.style.color = 'red';
                return;
            }

            const inputDataTextarea = document.getElementById('inputDataTextarea');
            let dataToEncrypt;
            let encryptedMessageJSON;
            let decodedData;

            try {
                // 1. Parsowanie danych wej≈õciowych z textarea
                dataToEncrypt = JSON.parse(inputDataTextarea.value);

                // 2. SZYFROWANIE: Wywo≈Çanie funkcji tworzƒÖcej zaszyfrowanƒÖ wiadomo≈õƒá
                // W realnej aplikacji wynik by≈Çby wys≈Çany do serwera (u≈ºywamy GLOBAL_PUB_KEY do wrapKey).
                encryptedMessageJSON = await create_encrypted_message(dataToEncrypt, GLOBAL_PUB_KEY);

                // --- Symulacja transmisji ---
                // Tutaj 'encryptedMessageJSON' to dane, kt√≥re by≈Çyby przes≈Çane (wk, iv, ct).

                // 3. DESZYFROWANIE: Wywo≈Çanie funkcji deszyfrujƒÖcej i walidujƒÖcej schemat
                // Serwer (lub inna strona) u≈ºywa GLOBAL_PRIV_KEY do unwrapKey.
                decodedData = await create_decrypted_message(encryptedMessageJSON, GLOBAL_PRIV_KEY, GLOBAL_SCHEMA);

                // 4. Wy≈õwietlenie wyniku
                document.getElementById('outputDataTextarea').value = JSON.stringify(decodedData, null, 2);
                ERROR_DISPLAY.textContent = '‚úÖ Sukces! Szyfrowanie, deszyfrowanie i walidacja schematu udane.';
                ERROR_DISPLAY.style.color = 'green';

            } catch (error) {
                ERROR_DISPLAY.textContent = `‚ùå B≈ÇƒÖd w procesie testowania: ${error.message}`;
                ERROR_DISPLAY.style.color = 'red';
                document.getElementById('outputDataTextarea').value = '';
            }
        }

        // Inicjalizacja stanu przycisku
        document.addEventListener('DOMContentLoaded', checkDependencies);



        // ===============================================
        // === CZƒò≈öCI TYLKO DLA 3 ZAK≈ÅADKI
        // ===============================================


        // TYMCZASOWA FUNKCJA DO ≈ÅADOWANIA DANYCH Z LOCAL-STORAGE
        function LoadEncryptedMessage() {
            const storageKey = 'simulationOfServerDB';
            let dbArray = [];

            // 1. Wczytaj istniejƒÖcƒÖ zawarto≈õƒá
            const storedData = localStorage.getItem(storageKey);

            if (storedData) {
                try {
                    dbArray = JSON.parse(storedData);
                    // Upewnij siƒô, ≈ºe to jest tablica
                    if (!Array.isArray(dbArray)) {
                        console.warn("Dane w Local Storage nie sƒÖ tablicƒÖ. ZostanƒÖ zresetowane.");
                        dbArray = [];
                    }
                } catch (e) {
                    console.error("B≈ÇƒÖd parsowania Local Storage. Dane zostanƒÖ zresetowane.", e);
                    dbArray = [];
                }
            }

            return dbArray;
        }

        // TYMCZASOWA FUNKCJA DO CZYSZCZENIA DANYCH Z LOCAL-STORAGE
        function ClearServerSimulation(){
            const storageKey = 'simulationOfServerDB';
            localStorage.removeItem(storageKey);
        }


        // Zmienna globalna przechowujƒÖca po≈ÇƒÖczone rekordy JSON
        let globalRecords = [];

        // Elementy DOM
        const jsonFileInput = document.getElementById('jsonFileInput');
        const loadStatus = document.getElementById('loadStatus');
        const useGlobalDataCheckbox = document.getElementById('useGlobalDataCheckbox');
        const displayDataBtn = document.getElementById('displayDataBtn');
        const clearDataBtn = document.getElementById('clearDataBtn');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const dataDisplayArea = document.getElementById('dataDisplayArea');

        /**
         * U≈ÇatwiajƒÖca funkcja do pobierania danych na podstawie stanu checkboxa.
         * Zwraca Promise, kt√≥ry rozwiƒÖzuje siƒô z tablicƒÖ rekord√≥w.
         */
        function getRecords() {
            return new Promise((resolve, reject) => {
                if (useGlobalDataCheckbox.checked) {
                    // Dane ze zmiennej globalnej
                    if (globalRecords.length > 0) {
                        console.log('Dane pobrane ze zmiennej globalnej.');
                        resolve(globalRecords);
                    } else {
                        reject('Brak danych w zmiennej globalnej. Wczytaj pliki JSON.');
                    }
                } else {
                    // Dane z serwera (POST)
                    console.log('Pobieranie danych z serwera...');
                    // TUTAJ MIEJSCE NA LOGIKƒò POBIERANIA Z SERWERA (fetch/axios POST)
                    // Przyk≈Çad:
                    /*
                    fetch('/api/get-records', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({})
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log('Dane pobrane z serwera.', data);
                        resolve(data); // data to powinna byƒá array obiekt√≥w (rekord√≥w)
                    })
                    .catch(error => {
                        console.error('B≈ÇƒÖd pobierania danych z serwera:', error);
                        reject('Nie uda≈Ço siƒô pobraƒá danych z serwera.');
                    });
                    */
                    
                    // TYMCZASOWO
                    const data = LoadEncryptedMessage();
                    resolve(decryptArray(data) );
                }
            });
        }

        // funkcja zwracajƒÖca tablicƒô odszyfrowanych danych
        async function decryptArray(data) {
            // 1. Inicjalizacja tablicy na odszyfrowane dane
            const decryptedArray = [];
            // 2. Iteracja po ka≈ºdym elemencie w tablicy 'data'
            for (const element of data) {
                try {
                    if (!element || !element.encryptedData) {
                        console.error("B≈ÇƒÖd: Element lub pole 'encryptedData' jest nieobecne.", element);
                        continue; // Przechodzi do nastƒôpnego elementu
                    }
                    
                    const decodedData = await create_decrypted_message(element.encryptedData, GLOBAL_PRIV_KEY, GLOBAL_SCHEMA);
                    
                    // 5. Dodanie odszyfrowanych danych do tablicy wynikowej
                    decryptedArray.push(decodedData);

                } catch (error) {
                    console.error("B≈ÇƒÖd podczas przetwarzania elementu:", error, "Element:", element);
                }
            }

            // 6. Zwr√≥cenie tablicy odszyfrowanych danych
            return decryptedArray;
        }

        /**
         * Generuje i wy≈õwietla tabelƒô HTML z rekord√≥w.
         * @param {Array<Object>} records - Tablica obiekt√≥w (rekord√≥w) do wy≈õwietlenia.
         */
        function displayTable(records) {
            dataDisplayArea.innerHTML = ''; // Czy≈õci poprzedni widok

            if (!Array.isArray(records) || records.length === 0) {
                dataDisplayArea.innerHTML = '<p style="color: red;">Brak danych do wy≈õwietlenia.</p>';
                return;
            }

            // 1. Nazwy kolumn z kluczy pierwszego obiektu
            const headers = Object.keys(records[0]);
            
            let tableHTML = '<table>';
            
            // Nag≈Ç√≥wek tabeli
            tableHTML += '<thead><tr>';
            headers.forEach(header => {
                tableHTML += `<th>${header}</th>`;
            });
            tableHTML += '</tr></thead>';

            // Cia≈Ço tabeli
            tableHTML += '<tbody>';
            records.forEach(record => {
                tableHTML += '<tr>';
                headers.forEach(header => {
                    // U≈ºywamy safe access (np. String(record[header]) || '') na wypadek braku klucza
                    // lub warto≈õci, ale zwykle JSONy sƒÖ sp√≥jne.
                    const value = record[header] !== undefined ? record[header] : '';
                    tableHTML += `<td>${value}</td>`;
                });
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody></table>';

            dataDisplayArea.innerHTML = tableHTML;
        }

        /**
         * Parsuje pliki JSON i ≈ÇƒÖczy je w globalnƒÖ tablicƒô.
         */
        function handleFileSelect(event) {
            const files = event.target.files;
            globalRecords = []; // Reset globalnej tablicy

            if (files.length === 0) {
                loadStatus.style.display = 'none';
                return;
            }

            let filesProcessed = 0;
            loadStatus.style.display = 'none'; // Ukryj na czas przetwarzania
            
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        const jsonArray = JSON.parse(content);

                        // Walidacja: czy jest tablicƒÖ i czy elementy sƒÖ obiektami
                        if (Array.isArray(jsonArray) && jsonArray.every(item => typeof item === 'object' && item !== null && !Array.isArray(item))) {
                            // Po≈ÇƒÖczenie rekord√≥w
                            globalRecords = globalRecords.concat(jsonArray);
                            console.log(`Pomy≈õlnie wczytano ${jsonArray.length} rekord√≥w z pliku: ${file.name}`);
                        } else {
                            console.error(`Plik ${file.name} nie zawiera tablicy obiekt√≥w.`);
                            alert(`B≈ÇƒÖd: Plik ${file.name} nie zawiera tablicy obiekt√≥w. Przetwarzanie przerwane.`);
                            jsonFileInput.value = ''; // Wyczy≈õƒá input
                            globalRecords = []; // Usu≈Ñ czƒô≈õciowo wczytane dane
                            loadStatus.style.display = 'none';
                            return;
                        }

                    } catch (error) {
                        console.error(`B≈ÇƒÖd parsowania pliku ${file.name}:`, error);
                        alert(`B≈ÇƒÖd parsowania pliku: ${file.name}. Upewnij siƒô, ≈ºe to poprawny JSON.`);
                        jsonFileInput.value = ''; // Wyczy≈õƒá input
                        globalRecords = []; // Usu≈Ñ czƒô≈õciowo wczytane dane
                        loadStatus.style.display = 'none';
                        return;
                    }
                    
                    filesProcessed++;
                    if (filesProcessed === files.length) {
                        // Wszystkie pliki przetworzone
                        loadStatus.innerText = `‚úÖ Sukces: Wczytano i po≈ÇƒÖczono ${globalRecords.length} rekord√≥w z ${files.length} plik√≥w!`;
                        loadStatus.style.display = 'block';
                        console.log('Ostateczna liczba rekord√≥w:', globalRecords.length);
                    }
                };
                reader.readAsText(file);
            });
        }

        /**
         * Pobiera dane i uruchamia funkcjƒô wy≈õwietlajƒÖcƒÖ je w tabeli.
         */
        function handleDisplayData() {
            dataDisplayArea.innerHTML = '<p>≈Åadowanie danych...</p>';
            getRecords()
                .then(records => {
                    displayTable(records);
                })
                .catch(error => {
                    dataDisplayArea.innerHTML = `<p style="color: red;">‚ùå B≈ÇƒÖd: ${error}</p>`;
                    console.error('B≈ÇƒÖd wy≈õwietlania danych:', error);
                });
        }

        /**
         * Obs≈Çuguje usuwanie danych (lokalnie lub na serwerze).
         */
        async function handleClearData() {
            dataDisplayArea.innerHTML = ''; // Czy≈õci widok
            
            if (useGlobalDataCheckbox.checked) {
                // Usu≈Ñ zmiennƒÖ globalnƒÖ i zapisz jej zawarto≈õƒá przed usuniƒôciem
                if (globalRecords.length > 0) {
                    downloadJSON_dated(globalRecords, 'cleared_local_data_backup');
                    globalRecords = [];
                    loadStatus.innerText = '‚úÖ Sukces: Dane globalne usuniƒôte. Utworzono kopiƒô zapasowƒÖ.';
                    loadStatus.style.display = 'block';
                    jsonFileInput.value = ''; // Czy≈õcimy input
                } else {
                    alert('Brak danych do usuniƒôcia w zmiennej globalnej.');
                    loadStatus.style.display = 'none';
                }
            } else {
                // Usu≈Ñ z serwera i zapisz zawarto≈õƒá bazy danych (zwr√≥conƒÖ przez serwer)
                console.log('Wysy≈Çanie POST do usuniƒôcia danych z serwera...');
                // TUTAJ MIEJSCE NA LOGIKƒò USUWANIA Z SERWERA (POST - zwraca dane, potem usuwa)
                // Przyk≈Çad:
                /*
                fetch('/api/clear-records', { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({}) // Mo≈ºe zawieraƒá token, etc.
                })
                .then(response => response.json())
                .then(data => {
                    // data to powinna byƒá array obiekt√≥w zwr√≥cona przed usuniƒôciem
                    if (Array.isArray(data) && data.length > 0) {
                        downloadJSON_dated(data, 'cleared_server_data_backup');
                        loadStatus.innerText = '‚úÖ Sukces: Dane z serwera usuniƒôte. Utworzono kopiƒô zapasowƒÖ.';
                        loadStatus.style.display = 'block';
                    } else {
                        alert('Serwer zwr√≥ci≈Ç puste dane lub b≈ÇƒÖd podczas usuwania.');
                        loadStatus.style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('B≈ÇƒÖd usuwania danych z serwera:', error);
                    alert('Nie uda≈Ço siƒô usunƒÖƒá danych z serwera.');
                    loadStatus.style.display = 'none';
                });
                */
                // TYMCZASOWO
                const data = LoadEncryptedMessage();
                const DataToExport = await decryptArray(data);
                console.log(DataToExport, DataToExport.length);
                if (DataToExport.length >= 1){
                    downloadJSON_dated(DataToExport, 'cleared_server_data_backup');
                }
                ClearServerSimulation();
            }
        }

        /**
         * Obs≈Çuguje eksport danych (lokalnie lub z serwera).
         */
        function handleExportData() {
            if (useGlobalDataCheckbox.checked) {
                // Eksport ze zmiennej globalnej
                if (globalRecords.length > 0) {
                    downloadJSON_dated(globalRecords, 'exported_local_data');
                } else {
                    alert('Brak danych do eksportu w zmiennej globalnej.');
                }
            } else {
                // Eksport z serwera: pobiera dane POSTem (tak jak "Wy≈õwietl Dane") i eksportuje
                console.log('Pobieranie danych z serwera do eksportu...');
                // getRecords() u≈ºywa tego samego POSTa
                getRecords()
                    .then(records => {
                        if (records.length > 0) {
                            downloadJSON_dated(records, 'exported_server_data');
                        } else {
                            alert('Serwer zwr√≥ci≈Ç puste dane do eksportu.');
                        }
                    })
                    .catch(error => {
                        console.error('B≈ÇƒÖd eksportu danych z serwera:', error);
                        alert('Nie uda≈Ço siƒô pobraƒá danych z serwera do eksportu.');
                    });
            }
        }

        // Dodanie s≈Çuchaczy zdarze≈Ñ
        jsonFileInput.addEventListener('change', handleFileSelect);
        displayDataBtn.addEventListener('click', handleDisplayData);
        clearDataBtn.addEventListener('click', handleClearData);
        exportDataBtn.addEventListener('click', handleExportData);



    </script>
</body>
</html>